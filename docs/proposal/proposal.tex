\documentclass[12pt]{article}
\usepackage[margin=0.75in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{setspace}
\usepackage{titling}
\usepackage{titlesec}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage[pdftex]{graphicx}
\usepackage{pdfpages}
\usepackage{multirow}

\setlength{\parskip}{1.0em}
\setlength{\headsep}{1em}
\setlength{\headheight}{0em}
\setlength{\parindent}{0em}

\titlespacing*{\section}
{0pt}{1em}{0pt}
\titlespacing*{\subsection}
{0pt}{0pt}{0pt}
\titlespacing*{\subsubsection}
{0pt}{0pt}{0pt}

\pretitle{\noindent \LARGE}
\posttitle{}
\preauthor{\hfill}
\postauthor{;\em}
\predate{}
\postdate{}

\title{Project Proposal}
\author{Andrew Palmer, Mark Roth}

\begin{document}
    \maketitle

    \section{Problem Description}
    Many applications are structured into client and server portions, separated by the Internet.
    Typically these applications use some kind of remote procedure call protocol to communicate between the client and the server.
    When you look at what many of these remote procedures actually accomplish, however, you quickly find that they are often dedicated to creating, reading, updating, and deleting resources on the server -- in effect, data synchronization.
    Often these portions of the RPC interface start to become an architectural sinkhole, where they don't really do anything meaningful, only proxying data directly to and from the database.
    As a result, they become a source of code bloat and unnecessary complexity that increases development time and makes it harder to add new features, but doesn't add any value to the system.
    The worst case of this problem is where, baring security, you could just expose the database to the clients directly and it would make little difference to the server's provided functionality.

    These fragile CRUD remote interfaces have another drawback that manifests on the client side.
    The highly specific server interface tends to create very specific interactions around different resources in the client.
    Over time this results in duplicated code as each type of resource ends up with its own ad-hoc synchronization mechanism.
    This can develop into considerable complexity, as discussed by Facebook in their \href{https://engineering.fb.com/2020/03/02/data-infrastructure/messenger/}{Project LightSpeed case study}, where among other anti-patterns, this managed to accumulate 1.7 million lines of code in the Facebook Messenger client.
    Another problem with these ad-hoc data models in the client is that they tend to be fairly inflexible, making it harder to build rich user interfaces without duplicating views or to quickly iterate on new user interface designs.
    Often in such systems adding a new user interface requires modifying the UI code, the inner client code that interfaces with the network, and adding new code to the server.

        \subsection{Desirable Architectural Characteristics}
            \subsubsection{Robustness}
            Robustness is critical for solving data synchronization. If data is corrupted due to errors, ...
            \subsubsection{Scalability}
            Lots of users. Not as much data/user but still significant amount.
            \subsubsection{Performance}
            Slow sync is no better than doing it by hand.
            \subsubsection{Portability}
            \subsubsection{Extensibility}

    \section{Proposed Solution}
    % Overview
    We propose to create an abstract service that provides data synchronization (the "Sync Service"), allowing us to reuse the same service to manage data synchronization for many different applications.
    The service takes care of keeping the data stored on the server and cached on the client in sync. It will also perform access control for data, making sure users only have access to their own data.
    We can also introduce a common client library (the "Sync Client") that interfaces with the Sync Service, making building client applications far simpler and more uniform.
    We can leverage this uniformity to introduce more powerful storage and retrieval mechanisms on the client, probably using the widely available SQLite database.

    % Diagram
    \begin{figure}[h]
        \centering
        \includegraphics[width=\linewidth]{./diagrams.pdf}
        \caption{A high level diagram of the proposed architecture}
    \end{figure}

    Ideally to demonstrate the versatility of our system, we will be able to write several (1-3) simple clients.
    The focus of these clients will be demonstrating the system in different domains rather, so they won't have to be overcomplicated.
    Hopefully we can even demonstrate different platforms reusing the same service and common client code.

    \section{What Will We Learn}

\end{document}
